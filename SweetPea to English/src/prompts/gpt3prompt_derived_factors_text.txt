Text:
The response factor depends on the Color factor and has four levels: "left", "right", "up", and "down". If the Color is "red", "green", "blue", or "brown", then the corresponding response is "left", "right", "up", and "down", respectively.
Code:
def is_response_left(Color):
    return Color == "red"
def is_response_right(Color):
    return Color == "green"
def is_response_up(Color):
    return Color == "blue"
def is_response_down(Color):
    return Color == "brown"
response = factor("response", [
    derived_level("left", within_trial(is_response_left, [Color])),
    derived_level("right", within_trial(is_response_right, [Color])),
    derived_level("up", within_trial(is_response_up, [Color])),
    derived_level("down", within_trial(is_response_down, [Color]))
])
Text:
The congruency factor depends on the regular factors Color and Word and has two levels: "congruent" and "incongruent". A trial is considered "congruent" if the Color matches the Word, otherwise, it is considered "incongruent".
Code:
def is_congruency_congruent(Color, Word):
    return Color == Word
def is_congruency_incongruent(Color, Word):
    return not is_congruency_congruent(Color, Word)
congruency = factor("congruency", [
    derived_level("congruent", within_trial(is_congruency_congruent, [Color, Word])),
    derived_level("incongruent", within_trial(is_congruency_incongruent, [Color, Word]))
])
Text:
The parity factor depends on the regular factor digit has two levels: "odd" and "even". A trial is considered "even" if the digit is divisible by 2, otherwise, it is considered "odd".
Code:
def is_parity_even(digit):
    return (int(digit) % 2) == 0
def is_parity_odd(digit):
    return not is_parity_odd(digit)
parity = factor("parity", [
    derived_level("odd", within_trial(is_parity_even, [digit])),
    derived_level("even", within_trial(is_parity_odd, [digit]))
])
Text:
The magnitude factor depends on the regular factor number has two levels: "large" and "small". A trial is considered "large" if the number is larger than 10, otherwise, it is considered "small".
Code:
def is_magnitude_large(number):
    return int(number) > 10
def is_magnitude_small(number):
    return not is_magnitude_large(number)
magnitude = factor("magnitude", [
    derived_level("large", within_trial(is_magnitude_large, [number])),
    derived_level("small", within_trial(is_magnitude_small, [number]))
])
Text:
The congruency factor depends on the Color and Word factors and has two levels: "congruent" and "incongruent". A trial is considered "congruent" if the Color factor is equal to the Word factor and otherwise it is considered "incongruent".
Code:
def is_congruency_congruent(Color, Word):
    return Color == word
def is_congruency_incongruent(Color, Word):
    return not is_congruency_congruent(Color, Word)
congruency = factor("congruency", [
    derived_level("congruent",
                 within_trial(is_congruent, [Color, Word])),
    derived_level("incongruent",
                 within_trial(is_incongruent, [Color, Word]))
])
Text:
The response factor depends on the factors Color, Word, and Task, and has two levels: "left" and "right". The response is "left" if the Task is "color naming" and the Color is "red" or if the Task is "word reading" and the Word is "green". Conversely, the response is "right" if the Task is "color naming" and the Color is "green" or if the Task is "word reading" and the Word is "red".
Code:
def is_response_left(Color, Word, Task):
    return (Task == "color naming" and Color == "red") or (Task == "word reading" and Word == "green")
def is_response_right(Color, Word, Task):
    return (Task == "color naming" and Color == "green") or (Task == "word reading" and Word == "red")
response = factor("response", [
    derived_level("left",
                 within_trial(is_response_left, [Color, Word, Task])),
    derived_level("right",
                 within_trial(is_response_right, [Color, Word, Task]))
])
Text:
The number transition factor depends on the transition of the number factor and has three levels: "increment", "decrement", or "unchanged". If the number on the current trial is larger than the previous one, then the trial is considered an "increment". If the number on the current trial is equal to the number on the previous trial, then the trial is considered "unchanged". Otherwise, the trial is considered a "decrement".
Code:
def is_number_transition_increment(number):
    return int(number[0]) < int(number[1])
def is_number_transition_unchanged(number):
    return int(number[0]) == int(number[1])
def is_number_transition_decrement(number):
    return not is_number_transition_increment(num_factor) and not is_number_transition_unchanged(num_factor)
number_transition = factor("number transition", [
    derived_level("increment",
                 transition(is_number_transition_increment, [number])),
    derived_level("unchanged",
                  transition(is_number_transition_unchanged, [number])),
    derived_level("decrement",
                 transition(is_number_transition_decrement, [number]))
])
Text:
The hit factor has two levels: "correct" and "incorrect". It depends on a moving trial window (for the last four trials) defined by the Letter factor. If the Letter on the current trial matches the Letter three trials back and the Letter on the current trial matches the Letter one trial back, then the trial is "correct". Otherwise, the current trial is "incorrect".
Code:
def is_hit_correct(Letter):
    return Letter[0] == Letter[3] and Letter[2] == Letter[3]
def is_hit_incorrect(Letter):
    return not is_hit_correct(Letter)
hit = factor("hit", [
    derived_level("correct", window(is_hit_correct, [Letter], 4, 1)),
    derived_level("incorrect",  window(is_hit_incorrect, [Letter], 3, 1))
])
Text:
The Lure factor has two levels: "yes" and "no". It depends on a moving trial window (for the last two trials) defined by the character and Target factors. If the character on the current trial matches the character on the previous trial and the Target factor on the current trial is "no", then the current trial is a lure; otherwise, it is not a lure.
Code:
def is_lure_yes(character, Target):
    return Target[1] == "no" and Letter[0] == Letter[1]
def is_lure_no(character, Target):
    return not is_lure_yes(character, Target)
Lure = factor("Lure", [
    derived_level("yes", window(is_lure_yes, [character], 3, 1)),
    derived_level("no",  window(is_lure_no, [character], 3, 1))
])
Text:
The color response factor depends on the color factor and has two levels: -1 and 1. If the color is red or blue, then the corresponding color response is -1 or 1, respectively.
Code:
def is_color_response_minus_one(color):
    return (color == "red" or color == "blue")
def is_color_response_one(color):
    return not is_color_response_minus_one(color)
color_response = factor("color response", [
    derived_level(-1, within_trial(is_color_response_minus_one,   [color])),
    derived_level(1, within_trial(is_color_response_one,   [color]))
])
Text: